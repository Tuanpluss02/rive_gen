/// Generator for controller classes with type-safe input handling.
///
/// This file is a placeholder and will be expanded in the future.
library;

import '../config/rive_gen_config.dart';
import '../models/models.dart';
import '../utils/utils.dart';

class ControllerGenerator {
  /// The Rive asset to generate controller for
  final RiveAsset asset;

  /// The generator configuration
  final RiveGenConfig config;

  /// Constructor
  const ControllerGenerator({required this.asset, required this.config});

  /// Generate the complete controller class code
  String generate() {
    final className = NamingUtils.generateClassName(
      '${asset.name}_controller',
      prefix: config.classPrefix,
      suffix: config.classSuffix,
    );

    final buffer = StringBuffer();

    // File header and imports
    _writeHeader(buffer, className);

    // Main controller class
    _writeControllerClass(buffer, className);

    // State machine controllers
    _writeStateMachineControllers(buffer);

    // Input controllers
    _writeInputControllers(buffer);

    // Animation controllers
    _writeAnimationControllers(buffer);

    return buffer.toString();
  }

  /// Write file header and imports
  void _writeHeader(StringBuffer buffer, String className) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by rive_gen');
    buffer.writeln('');
    buffer.writeln('/// Controller class for ${asset.name}.riv');
    buffer.writeln('/// ');
    buffer.writeln(
      '/// This file provides type-safe access to control Rive animations,',
    );
    buffer.writeln(
      '/// state machines, and inputs for the ${asset.name} asset.',
    );
    buffer.writeln(
      'library ${NamingUtils.toSnakeCase(asset.name)}_controller;',
    );
    buffer.writeln('');
    buffer.writeln("import 'package:rive/rive.dart';");
    buffer.writeln('');
  }

  /// Write the main controller class
  void _writeControllerClass(StringBuffer buffer, String className) {
    final assetClassName = NamingUtils.generateClassName(
      asset.name,
      prefix: config.classPrefix,
      suffix: config.classSuffix,
    );

    buffer.writeln('/// Main controller for ${asset.name}.riv asset');
    buffer.writeln('/// ');
    buffer.writeln(
      '/// Provides type-safe access to artboards, state machines,',
    );
    buffer.writeln('/// animations, and inputs.');
    buffer.writeln('class $className {');
    buffer.writeln('  /// The Rive file instance');
    buffer.writeln('  final RiveFile _riveFile;');
    buffer.writeln('');
    buffer.writeln('  /// The currently active artboard');
    buffer.writeln('  Artboard? _artboard;');
    buffer.writeln('');
    buffer.writeln('  /// State machine controllers by name');
    buffer.writeln(
      '  final Map<String, StateMachineController> _stateMachineControllers = {};',
    );
    buffer.writeln('');
    buffer.writeln('  /// Simple animation controllers by name');
    buffer.writeln(
      '  final Map<String, SimpleAnimation> _animationControllers = {};',
    );
    buffer.writeln('');
    buffer.writeln('  /// Constructor');
    buffer.writeln('  $className(this._riveFile);');
    buffer.writeln('');

    // Factory constructor for loading from asset
    buffer.writeln('  /// Create controller from asset path');
    buffer.writeln('  static Future<$className> fromAsset() async {');
    buffer.writeln(
      "    final data = await RootBundle.load($assetClassName.path);",
    );
    buffer.writeln('    final file = RiveFile.import(data);');
    buffer.writeln('    return $className(file);');
    buffer.writeln('  }');
    buffer.writeln('');

    // Artboard access
    buffer.writeln('  /// Get artboard by name');
    buffer.writeln('  Artboard? getArtboard([String? name]) {');
    buffer.writeln('    if (name != null) {');
    buffer.writeln('      return _riveFile.artboardByName(name);');
    buffer.writeln('    }');
    buffer.writeln('    return _riveFile.mainArtboard;');
    buffer.writeln('  }');
    buffer.writeln('');

    // Set active artboard
    buffer.writeln('  /// Set the active artboard');
    buffer.writeln('  void setArtboard([String? name]) {');
    buffer.writeln('    _artboard = getArtboard(name);');
    buffer.writeln('  }');
    buffer.writeln('');

    // Get current artboard
    buffer.writeln('  /// Get the currently active artboard');
    buffer.writeln(
      '  Artboard? get artboard => _artboard ?? _riveFile.mainArtboard;',
    );
    buffer.writeln('');

    // Artboard-specific controllers
    if (asset.artboards.isNotEmpty) {
      for (final artboard in asset.artboards) {
        final artboardControllerName = NamingUtils.generateClassName(
          '${asset.name}_${artboard.name}_controller',
        );
        final propertyName = NamingUtils.generatePropertyName(
          '${artboard.name}Artboard',
        );

        buffer.writeln('  /// Get controller for ${artboard.name} artboard');
        buffer.writeln(
          '  $artboardControllerName get $propertyName => $artboardControllerName(this, "${artboard.name}");',
        );
        buffer.writeln('');
      }
    }

    // State machine access
    buffer.writeln('  /// Get state machine controller by name');
    buffer.writeln(
      '  StateMachineController? getStateMachineController(String name) {',
    );
    buffer.writeln('    if (_stateMachineControllers.containsKey(name)) {');
    buffer.writeln('      return _stateMachineControllers[name];');
    buffer.writeln('    }');
    buffer.writeln('');
    buffer.writeln('    final artboard = this.artboard;');
    buffer.writeln('    if (artboard == null) return null;');
    buffer.writeln('');
    buffer.writeln(
      '    final controller = StateMachineController.fromArtboard(artboard, name);',
    );
    buffer.writeln('    if (controller != null) {');
    buffer.writeln('      artboard.addController(controller);');
    buffer.writeln('      _stateMachineControllers[name] = controller;');
    buffer.writeln('    }');
    buffer.writeln('    return controller;');
    buffer.writeln('  }');
    buffer.writeln('');

    // Animation access
    buffer.writeln('  /// Get simple animation controller by name');
    buffer.writeln('  SimpleAnimation? getAnimationController(String name) {');
    buffer.writeln('    if (_animationControllers.containsKey(name)) {');
    buffer.writeln('      return _animationControllers[name];');
    buffer.writeln('    }');
    buffer.writeln('');
    buffer.writeln('    final artboard = this.artboard;');
    buffer.writeln('    if (artboard == null) return null;');
    buffer.writeln('');
    buffer.writeln(
      '    final animation = artboard.animations.firstWhereOrNull((anim) => anim.name == name);',
    );
    buffer.writeln('    if (animation != null) {');
    buffer.writeln('      final controller = SimpleAnimation(name);');
    buffer.writeln('      artboard.addController(controller);');
    buffer.writeln('      _animationControllers[name] = controller;');
    buffer.writeln('      return controller;');
    buffer.writeln('    }');
    buffer.writeln('    return null;');
    buffer.writeln('  }');
    buffer.writeln('');

    // Cleanup
    buffer.writeln('  /// Dispose all controllers');
    buffer.writeln('  void dispose() {');
    buffer.writeln(
      '    for (final controller in _stateMachineControllers.values) {',
    );
    buffer.writeln('      controller.dispose();');
    buffer.writeln('    }');
    buffer.writeln('    _stateMachineControllers.clear();');
    buffer.writeln('    _animationControllers.clear();');
    buffer.writeln('  }');
    buffer.writeln('');

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write artboard-specific controller classes
  void _writeStateMachineControllers(StringBuffer buffer) {
    for (final artboard in asset.artboards) {
      final artboardControllerName = NamingUtils.generateClassName(
        '${asset.name}_${artboard.name}_controller',
      );

      buffer.writeln('/// Controller for ${artboard.name} artboard');
      buffer.writeln('class $artboardControllerName {');
      buffer.writeln('  /// The main controller');
      buffer.writeln(
        '  final ${NamingUtils.generateClassName('${asset.name}_controller', prefix: config.classPrefix, suffix: config.classSuffix)} _controller;',
      );
      buffer.writeln('');
      buffer.writeln('  /// The artboard name');
      buffer.writeln('  final String _artboardName;');
      buffer.writeln('');
      buffer.writeln('  /// Constructor');
      buffer.writeln(
        '  $artboardControllerName(this._controller, this._artboardName);',
      );
      buffer.writeln('');

      // State machine accessors
      if (artboard.stateMachines.isNotEmpty) {
        buffer.writeln('  /// State machines for this artboard');
        for (final stateMachine in artboard.stateMachines) {
          final smControllerName = NamingUtils.generateClassName(
            '${asset.name}_${artboard.name}_${stateMachine.name}_sm_controller',
          );
          final propertyName = NamingUtils.generatePropertyName(
            stateMachine.name,
          );

          buffer.writeln('  /// ${stateMachine.name} state machine controller');
          buffer.writeln(
            '  $smControllerName get $propertyName => $smControllerName(_controller, _artboardName, "${stateMachine.name}");',
          );
          buffer.writeln('');
        }
      }

      // Animation accessors
      if (artboard.animations.isNotEmpty) {
        buffer.writeln('  /// Animations for this artboard');
        for (final animation in artboard.animations) {
          final animControllerName = NamingUtils.generateClassName(
            '${asset.name}_${artboard.name}_${animation.name}_anim_controller',
          );
          final propertyName = NamingUtils.generatePropertyName(animation.name);

          buffer.writeln('  /// ${animation.name} animation controller');
          buffer.writeln(
            '  $animControllerName get $propertyName => $animControllerName(_controller, _artboardName, "${animation.name}");',
          );
          buffer.writeln('');
        }
      }

      buffer.writeln('}');
      buffer.writeln('');

      // Individual state machine controllers
      for (final stateMachine in artboard.stateMachines) {
        _writeStateMachineController(buffer, artboard, stateMachine);
      }

      // Individual animation controllers
      for (final animation in artboard.animations) {
        _writeAnimationController(buffer, artboard, animation);
      }
    }
  }

  /// Write individual state machine controller
  void _writeStateMachineController(
    StringBuffer buffer,
    RiveArtboard artboard,
    RiveStateMachine stateMachine,
  ) {
    final smControllerName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${stateMachine.name}_sm_controller',
    );
    final mainControllerName = NamingUtils.generateClassName(
      '${asset.name}_controller',
      prefix: config.classPrefix,
      suffix: config.classSuffix,
    );

    buffer.writeln(
      '/// Controller for ${stateMachine.name} state machine in ${artboard.name} artboard',
    );
    buffer.writeln('class $smControllerName {');
    buffer.writeln('  /// The main controller');
    buffer.writeln('  final $mainControllerName _controller;');
    buffer.writeln('');
    buffer.writeln('  /// The artboard name');
    buffer.writeln('  final String _artboardName;');
    buffer.writeln('');
    buffer.writeln('  /// The state machine name');
    buffer.writeln('  final String _stateMachineName;');
    buffer.writeln('');
    buffer.writeln('  /// Cached state machine controller');
    buffer.writeln('  StateMachineController? _smController;');
    buffer.writeln('');
    buffer.writeln('  /// Constructor');
    buffer.writeln(
      '  $smControllerName(this._controller, this._artboardName, this._stateMachineName);',
    );
    buffer.writeln('');

    // Get state machine controller
    buffer.writeln('  /// Get the underlying state machine controller');
    buffer.writeln('  StateMachineController? get controller {');
    buffer.writeln(
      '    _smController ??= _controller.getStateMachineController(_stateMachineName);',
    );
    buffer.writeln('    return _smController;');
    buffer.writeln('  }');
    buffer.writeln('');

    // Input accessors
    if (stateMachine.inputs.isNotEmpty) {
      buffer.writeln('  /// Inputs for this state machine');
      final inputsControllerName = NamingUtils.generateClassName(
        '${asset.name}_${artboard.name}_${stateMachine.name}_inputs_controller',
      );
      buffer.writeln(
        '  $inputsControllerName get inputs => $inputsControllerName(this);',
      );
      buffer.writeln('');
    }

    // State queries
    if (stateMachine.states.isNotEmpty) {
      buffer.writeln('  /// Check if state machine is in a specific state');
      buffer.writeln('  bool isInState(String stateName) {');
      buffer.writeln('    final ctrl = controller;');
      buffer.writeln('    if (ctrl == null) return false;');
      buffer.writeln('    // Note: This is a placeholder implementation');
      buffer.writeln(
        '    // Real implementation would need to check layer states',
      );
      buffer.writeln('    return false;');
      buffer.writeln('  }');
      buffer.writeln('');

      // State constants
      buffer.writeln('  /// Available states');
      for (final state in stateMachine.states) {
        final constantName = NamingUtils.toSnakeCase(state).toUpperCase();
        buffer.writeln("  static const String $constantName = '$state';");
      }
      buffer.writeln('');
    }

    buffer.writeln('}');
    buffer.writeln('');

    // Inputs controller if there are inputs
    if (stateMachine.inputs.isNotEmpty) {
      _writeInputsController(buffer, artboard, stateMachine);
    }
  }

  /// Write inputs controller for a state machine
  void _writeInputsController(
    StringBuffer buffer,
    RiveArtboard artboard,
    RiveStateMachine stateMachine,
  ) {
    final inputsControllerName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${stateMachine.name}_inputs_controller',
    );
    final smControllerName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${stateMachine.name}_sm_controller',
    );

    buffer.writeln(
      '/// Inputs controller for ${stateMachine.name} state machine',
    );
    buffer.writeln('class $inputsControllerName {');
    buffer.writeln('  /// The state machine controller');
    buffer.writeln('  final $smControllerName _smController;');
    buffer.writeln('');
    buffer.writeln('  /// Constructor');
    buffer.writeln('  $inputsControllerName(this._smController);');
    buffer.writeln('');

    // Individual input accessors
    for (final input in stateMachine.inputs) {
      final propertyName = NamingUtils.generatePropertyName(input.name);

      switch (input.type) {
        case RiveInputType.trigger:
          buffer.writeln('  /// Fire ${input.name} trigger');
          buffer.writeln(
            '  void fire${NamingUtils.toPascalCase(input.name)}() {',
          );
          buffer.writeln('    final ctrl = _smController.controller;');
          buffer.writeln('    if (ctrl != null) {');
          buffer.writeln(
            "      final input = ctrl.findSMI('${input.name}') as SMITrigger?;",
          );
          buffer.writeln('      input?.fire();');
          buffer.writeln('    }');
          buffer.writeln('  }');
          buffer.writeln('');

          buffer.writeln('  /// Get ${input.name} trigger input');
          buffer.writeln('  SMITrigger? get $propertyName {');
          buffer.writeln('    final ctrl = _smController.controller;');
          buffer.writeln('    if (ctrl != null) {');
          buffer.writeln(
            "      return ctrl.findSMI('${input.name}') as SMITrigger?;",
          );
          buffer.writeln('    }');
          buffer.writeln('    return null;');
          buffer.writeln('  }');
          buffer.writeln('');
          break;

        case RiveInputType.boolean:
          buffer.writeln('  /// Set ${input.name} boolean value');
          buffer.writeln('  set $propertyName(bool value) {');
          buffer.writeln('    final ctrl = _smController.controller;');
          buffer.writeln('    if (ctrl != null) {');
          buffer.writeln(
            "      final input = ctrl.findSMI('${input.name}') as SMIBool?;",
          );
          buffer.writeln('      if (input != null) input.value = value;');
          buffer.writeln('    }');
          buffer.writeln('  }');
          buffer.writeln('');

          buffer.writeln('  /// Get ${input.name} boolean value');
          buffer.writeln('  bool get $propertyName {');
          buffer.writeln('    final ctrl = _smController.controller;');
          buffer.writeln('    if (ctrl != null) {');
          buffer.writeln(
            "      final input = ctrl.findSMI('${input.name}') as SMIBool?;",
          );
          buffer.writeln('      return input?.value ?? false;');
          buffer.writeln('    }');
          buffer.writeln('    return false;');
          buffer.writeln('  }');
          buffer.writeln('');
          break;

        case RiveInputType.number:
          buffer.writeln('  /// Set ${input.name} number value');
          buffer.writeln('  set $propertyName(double value) {');
          buffer.writeln('    final ctrl = _smController.controller;');
          buffer.writeln('    if (ctrl != null) {');
          buffer.writeln(
            "      final input = ctrl.findSMI('${input.name}') as SMINumber?;",
          );
          buffer.writeln('      if (input != null) input.value = value;');
          buffer.writeln('    }');
          buffer.writeln('  }');
          buffer.writeln('');

          buffer.writeln('  /// Get ${input.name} number value');
          buffer.writeln('  double get $propertyName {');
          buffer.writeln('    final ctrl = _smController.controller;');
          buffer.writeln('    if (ctrl != null) {');
          buffer.writeln(
            "      final input = ctrl.findSMI('${input.name}') as SMINumber?;",
          );
          buffer.writeln('      return input?.value ?? 0.0;');
          buffer.writeln('    }');
          buffer.writeln('    return 0.0;');
          buffer.writeln('  }');
          buffer.writeln('');
          break;
      }
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write individual animation controller
  void _writeAnimationController(
    StringBuffer buffer,
    RiveArtboard artboard,
    RiveAnimation animation,
  ) {
    final animControllerName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${animation.name}_anim_controller',
    );
    final mainControllerName = NamingUtils.generateClassName(
      '${asset.name}_controller',
      prefix: config.classPrefix,
      suffix: config.classSuffix,
    );

    buffer.writeln(
      '/// Controller for ${animation.name} animation in ${artboard.name} artboard',
    );
    buffer.writeln('class $animControllerName {');
    buffer.writeln('  /// The main controller');
    buffer.writeln('  final $mainControllerName _controller;');
    buffer.writeln('');
    buffer.writeln('  /// The artboard name');
    buffer.writeln('  final String _artboardName;');
    buffer.writeln('');
    buffer.writeln('  /// The animation name');
    buffer.writeln('  final String _animationName;');
    buffer.writeln('');
    buffer.writeln('  /// Cached animation controller');
    buffer.writeln('  SimpleAnimation? _animController;');
    buffer.writeln('');
    buffer.writeln('  /// Constructor');
    buffer.writeln(
      '  $animControllerName(this._controller, this._artboardName, this._animationName);',
    );
    buffer.writeln('');

    // Get animation controller
    buffer.writeln('  /// Get the underlying animation controller');
    buffer.writeln('  SimpleAnimation? get controller {');
    buffer.writeln(
      '    _animController ??= _controller.getAnimationController(_animationName);',
    );
    buffer.writeln('    return _animController;');
    buffer.writeln('  }');
    buffer.writeln('');

    // Animation control methods
    buffer.writeln('  /// Play the animation');
    buffer.writeln('  void play() {');
    buffer.writeln('    controller?.isActive = true;');
    buffer.writeln('  }');
    buffer.writeln('');

    buffer.writeln('  /// Pause the animation');
    buffer.writeln('  void pause() {');
    buffer.writeln('    controller?.isActive = false;');
    buffer.writeln('  }');
    buffer.writeln('');

    buffer.writeln('  /// Reset the animation');
    buffer.writeln('  void reset() {');
    buffer.writeln('    final ctrl = controller;');
    buffer.writeln('    if (ctrl != null) {');
    buffer.writeln('      ctrl.reset();');
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln('');

    // Animation properties
    buffer.writeln('  /// Check if animation is playing');
    buffer.writeln('  bool get isPlaying => controller?.isActive ?? false;');
    buffer.writeln('');

    buffer.writeln('  /// Get animation time');
    buffer.writeln('  double get time => controller?.time ?? 0.0;');
    buffer.writeln('');

    buffer.writeln('  /// Set animation time');
    buffer.writeln('  set time(double value) {');
    buffer.writeln('    final ctrl = controller;');
    buffer.writeln('    if (ctrl != null) {');
    buffer.writeln('      ctrl.time = value;');
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln('');

    // Animation constants
    buffer.writeln('  /// Animation duration');
    buffer.writeln('  static const double duration = ${animation.duration};');
    buffer.writeln('');
    buffer.writeln('  /// Animation FPS');
    buffer.writeln('  static const double fps = ${animation.fps};');
    buffer.writeln('');
    buffer.writeln('  /// Is looping');
    buffer.writeln('  static const bool isLooping = ${animation.isLooping};');
    buffer.writeln('');

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write animation controllers - placeholder for future expansion
  void _writeAnimationControllers(StringBuffer buffer) {
    // Already handled in _writeStateMachineControllers
  }

  /// Write input controllers - placeholder for future expansion
  void _writeInputControllers(StringBuffer buffer) {
    // Already handled in _writeInputsController
  }
}
