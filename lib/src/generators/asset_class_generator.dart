import '../config/rive_gen_config.dart';
import '../models/models.dart';
import '../utils/utils.dart';

/// Generator for individual asset classes with comprehensive Rive metadata.
class AssetClassGenerator {
  /// The Rive asset to generate code for
  final RiveAsset asset;

  /// The generator configuration
  final RiveGenConfig config;

  /// Constructor
  const AssetClassGenerator({required this.asset, required this.config});

  /// Generate the complete asset class code
  String generate() {
    final className = NamingUtils.generateClassName(
      asset.name,
      prefix: config.classPrefix,
      suffix: config.classSuffix,
    );

    final buffer = StringBuffer();

    // File header and imports
    _writeHeader(buffer, className);

    // Main asset class
    _writeAssetClass(buffer, className);

    // Artboard classes
    _writeArtboardClasses(buffer);

    // State machine classes
    _writeStateMachineClasses(buffer);

    // Animation classes
    _writeAnimationClasses(buffer);

    // Input classes
    _writeInputClasses(buffer);

    return buffer.toString();
  }

  /// Write file header and documentation
  void _writeHeader(StringBuffer buffer, String className) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by rive_gen');
    buffer.writeln('');
    buffer.writeln('/// Generated asset class for ${asset.name}.riv');
    buffer.writeln('/// ');
    buffer.writeln(
      '/// This file contains type-safe access to all components within',
    );
    buffer.writeln(
      '/// the Rive file including artboards, state machines, animations,',
    );
    buffer.writeln('/// and inputs.');
    buffer.writeln('library ${NamingUtils.toSnakeCase(asset.name)}_asset;');
    buffer.writeln('');
  }

  /// Write the main asset class
  void _writeAssetClass(StringBuffer buffer, String className) {
    buffer.writeln('/// Main asset class for ${asset.name}.riv');
    buffer.writeln('class $className {');
    buffer.writeln('  /// Private constructor to prevent instantiation');
    buffer.writeln('  const $className._();');
    buffer.writeln('');

    // Basic asset properties
    buffer.writeln('  /// The path to the Rive asset');
    buffer.writeln("  static const String path = '${asset.path}';");
    buffer.writeln('');
    buffer.writeln('  /// The asset name');
    buffer.writeln("  static const String name = '${asset.name}';");
    buffer.writeln('');

    // Artboard access
    if (asset.artboards.isNotEmpty) {
      buffer.writeln('  /// All artboards in this asset');
      buffer.writeln(
        '  static const ${className}Artboards artboards = ${className}Artboards._();',
      );
      buffer.writeln('');

      // Default artboard shortcut
      final defaultArtboard = asset.defaultArtboard;
      if (defaultArtboard != null) {
        final artboardClassName = NamingUtils.generateClassName(
          '${asset.name}_${defaultArtboard.name}_artboard',
        );
        buffer.writeln('  /// Default artboard (${defaultArtboard.name})');
        buffer.writeln(
          '  static const $artboardClassName defaultArtboard = $artboardClassName._();',
        );
        buffer.writeln('');
      }
    }

    // Asset metadata
    buffer.writeln('  /// Total number of artboards');
    buffer.writeln(
      '  static const int artboardCount = ${asset.artboards.length};',
    );
    buffer.writeln('');

    // Animation count
    final totalAnimations = asset.artboards.fold<int>(
      0,
      (sum, artboard) => sum + artboard.animations.length,
    );
    buffer.writeln('  /// Total number of animations across all artboards');
    buffer.writeln('  static const int animationCount = $totalAnimations;');
    buffer.writeln('');

    // State machine count
    final totalStateMachines = asset.artboards.fold<int>(
      0,
      (sum, artboard) => sum + artboard.stateMachines.length,
    );
    buffer.writeln('  /// Total number of state machines across all artboards');
    buffer.writeln(
      '  static const int stateMachineCount = $totalStateMachines;',
    );
    buffer.writeln('');

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write artboard container class
  void _writeArtboardClasses(StringBuffer buffer) {
    if (asset.artboards.isEmpty) return;

    final className = NamingUtils.generateClassName(
      asset.name,
      prefix: config.classPrefix,
      suffix: config.classSuffix,
    );

    // Artboards container class
    buffer.writeln('/// Container for all artboards in ${asset.name}.riv');
    buffer.writeln('class ${className}Artboards {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const ${className}Artboards._();');
    buffer.writeln('');

    // Individual artboard properties
    for (final artboard in asset.artboards) {
      final artboardClassName = NamingUtils.generateClassName(
        '${asset.name}_${artboard.name}_artboard',
      );
      final propertyName = NamingUtils.generatePropertyName(artboard.name);

      buffer.writeln('  /// ${artboard.name} artboard');
      if (artboard.isDefault) {
        buffer.writeln('  /// (Default artboard)');
      }
      buffer.writeln(
        '  static const $artboardClassName $propertyName = $artboardClassName._();',
      );
      buffer.writeln('');
    }

    buffer.writeln('}');
    buffer.writeln('');

    // Individual artboard classes
    for (final artboard in asset.artboards) {
      _writeArtboardClass(buffer, artboard);
    }
  }

  /// Write individual artboard class
  void _writeArtboardClass(StringBuffer buffer, RiveArtboard artboard) {
    final artboardClassName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_artboard',
    );

    buffer.writeln('/// ${artboard.name} artboard from ${asset.name}.riv');
    if (artboard.isDefault) {
      buffer.writeln('/// This is the default artboard.');
    }
    buffer.writeln('class $artboardClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $artboardClassName._();');
    buffer.writeln('');

    // Basic properties
    buffer.writeln('  /// Artboard name');
    buffer.writeln("  static const String name = '${artboard.name}';");
    buffer.writeln('');
    buffer.writeln('  /// Is default artboard');
    buffer.writeln('  static const bool isDefault = ${artboard.isDefault};');
    buffer.writeln('');

    // State machines
    if (artboard.stateMachines.isNotEmpty) {
      buffer.writeln('  /// State machines in this artboard');
      buffer.writeln(
        '  static const ${artboardClassName}StateMachines stateMachines = ${artboardClassName}StateMachines._();',
      );
      buffer.writeln('');
    }

    // Animations
    if (artboard.animations.isNotEmpty) {
      buffer.writeln('  /// Animations in this artboard');
      buffer.writeln(
        '  static const ${artboardClassName}Animations animations = ${artboardClassName}Animations._();',
      );
      buffer.writeln('');
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write state machine classes for all artboards
  void _writeStateMachineClasses(StringBuffer buffer) {
    for (final artboard in asset.artboards) {
      if (artboard.stateMachines.isEmpty) continue;

      final artboardClassName = NamingUtils.generateClassName(
        '${asset.name}_${artboard.name}_artboard',
      );

      // State machines container
      buffer.writeln('/// State machines for ${artboard.name} artboard');
      buffer.writeln('class ${artboardClassName}StateMachines {');
      buffer.writeln('  /// Private constructor');
      buffer.writeln('  const ${artboardClassName}StateMachines._();');
      buffer.writeln('');

      for (final stateMachine in artboard.stateMachines) {
        final smClassName = NamingUtils.generateClassName(
          '${asset.name}_${artboard.name}_${stateMachine.name}_sm',
        );
        final propertyName = NamingUtils.generatePropertyName(
          stateMachine.name,
        );

        buffer.writeln('  /// ${stateMachine.name} state machine');
        buffer.writeln(
          '  static const $smClassName $propertyName = $smClassName._();',
        );
        buffer.writeln('');
      }

      buffer.writeln('}');
      buffer.writeln('');

      // Individual state machine classes
      for (final stateMachine in artboard.stateMachines) {
        _writeStateMachineClass(buffer, artboard, stateMachine);
      }
    }
  }

  /// Write individual state machine class
  void _writeStateMachineClass(
    StringBuffer buffer,
    RiveArtboard artboard,
    RiveStateMachine stateMachine,
  ) {
    final smClassName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${stateMachine.name}_sm',
    );

    buffer.writeln(
      '/// ${stateMachine.name} state machine from ${artboard.name} artboard',
    );
    buffer.writeln('class $smClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $smClassName._();');
    buffer.writeln('');

    // Basic properties
    buffer.writeln('  /// State machine name');
    buffer.writeln("  static const String name = '${stateMachine.name}';");
    buffer.writeln('');

    // States
    if (stateMachine.states.isNotEmpty) {
      buffer.writeln('  /// All states in this state machine');
      buffer.writeln('  static const List<String> states = [');
      for (final state in stateMachine.states) {
        buffer.writeln("    '$state',");
      }
      buffer.writeln('  ];');
      buffer.writeln('');
    }

    // Initial state
    if (stateMachine.initialState != null) {
      buffer.writeln('  /// Initial state');
      buffer.writeln(
        "  static const String initialState = '${stateMachine.initialState}';",
      );
      buffer.writeln('');
    }

    // Inputs
    if (stateMachine.inputs.isNotEmpty) {
      buffer.writeln('  /// Inputs for this state machine');
      buffer.writeln(
        '  static const ${smClassName}Inputs inputs = ${smClassName}Inputs._();',
      );
      buffer.writeln('');
    }

    buffer.writeln('}');
    buffer.writeln('');

    // Inputs class if there are inputs
    if (stateMachine.inputs.isNotEmpty) {
      _writeInputsClass(buffer, artboard, stateMachine);
    }
  }

  /// Write animation classes for all artboards
  void _writeAnimationClasses(StringBuffer buffer) {
    for (final artboard in asset.artboards) {
      if (artboard.animations.isEmpty) continue;

      final artboardClassName = NamingUtils.generateClassName(
        '${asset.name}_${artboard.name}_artboard',
      );

      // Animations container
      buffer.writeln('/// Animations for ${artboard.name} artboard');
      buffer.writeln('class ${artboardClassName}Animations {');
      buffer.writeln('  /// Private constructor');
      buffer.writeln('  const ${artboardClassName}Animations._();');
      buffer.writeln('');

      for (final animation in artboard.animations) {
        final animClassName = NamingUtils.generateClassName(
          '${asset.name}_${artboard.name}_${animation.name}_anim',
        );
        final propertyName = NamingUtils.generatePropertyName(animation.name);

        buffer.writeln('  /// ${animation.name} animation');
        buffer.writeln(
          '  static const $animClassName $propertyName = $animClassName._();',
        );
        buffer.writeln('');
      }

      buffer.writeln('}');
      buffer.writeln('');

      // Individual animation classes
      for (final animation in artboard.animations) {
        _writeAnimationClass(buffer, artboard, animation);
      }
    }
  }

  /// Write individual animation class
  void _writeAnimationClass(
    StringBuffer buffer,
    RiveArtboard artboard,
    RiveAnimation animation,
  ) {
    final animClassName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${animation.name}_anim',
    );

    buffer.writeln(
      '/// ${animation.name} animation from ${artboard.name} artboard',
    );
    buffer.writeln('class $animClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $animClassName._();');
    buffer.writeln('');

    // Animation properties
    buffer.writeln('  /// Animation name');
    buffer.writeln("  static const String name = '${animation.name}';");
    buffer.writeln('');
    buffer.writeln('  /// Duration in seconds');
    buffer.writeln('  static const double duration = ${animation.duration};');
    buffer.writeln('');
    buffer.writeln('  /// Frames per second');
    buffer.writeln('  static const double fps = ${animation.fps};');
    buffer.writeln('');
    buffer.writeln('  /// Total frames');
    buffer.writeln(
      '  static const int totalFrames = ${animation.totalFrames};',
    );
    buffer.writeln('');
    buffer.writeln('  /// Is looping');
    buffer.writeln('  static const bool isLooping = ${animation.isLooping};');
    buffer.writeln('');

    // Work area if defined
    if (animation.workAreaStart != null || animation.workAreaEnd != null) {
      buffer.writeln('  /// Work area start time');
      buffer.writeln(
        '  static const double? workAreaStart = ${animation.workAreaStart};',
      );
      buffer.writeln('');
      buffer.writeln('  /// Work area end time');
      buffer.writeln(
        '  static const double? workAreaEnd = ${animation.workAreaEnd};',
      );
      buffer.writeln('');
      buffer.writeln('  /// Effective duration (considering work area)');
      buffer.writeln(
        '  static const double effectiveDuration = ${animation.effectiveDuration};',
      );
      buffer.writeln('');
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write inputs class for a state machine
  void _writeInputsClass(
    StringBuffer buffer,
    RiveArtboard artboard,
    RiveStateMachine stateMachine,
  ) {
    final smClassName = NamingUtils.generateClassName(
      '${asset.name}_${artboard.name}_${stateMachine.name}_sm',
    );

    buffer.writeln('/// Inputs for ${stateMachine.name} state machine');
    buffer.writeln('class ${smClassName}Inputs {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const ${smClassName}Inputs._();');
    buffer.writeln('');

    // Group inputs by type
    final triggers = stateMachine.inputs
        .where((input) => input.type == RiveInputType.trigger)
        .toList();
    final booleans = stateMachine.inputs
        .where((input) => input.type == RiveInputType.boolean)
        .toList();
    final numbers = stateMachine.inputs
        .where((input) => input.type == RiveInputType.number)
        .toList();

    // Write trigger inputs
    if (triggers.isNotEmpty) {
      buffer.writeln('  // Trigger inputs');
      for (final trigger in triggers) {
        final inputClassName = NamingUtils.generateClassName(
          '${stateMachine.name}_${trigger.name}_trigger',
        );
        final propertyName = NamingUtils.generatePropertyName(trigger.name);

        buffer.writeln('  /// ${trigger.name} trigger input');
        buffer.writeln(
          '  static const $inputClassName $propertyName = $inputClassName._();',
        );
        buffer.writeln('');
      }
    }

    // Write boolean inputs
    if (booleans.isNotEmpty) {
      buffer.writeln('  // Boolean inputs');
      for (final boolean in booleans) {
        final inputClassName = NamingUtils.generateClassName(
          '${stateMachine.name}_${boolean.name}_boolean',
        );
        final propertyName = NamingUtils.generatePropertyName(boolean.name);

        buffer.writeln('  /// ${boolean.name} boolean input');
        buffer.writeln(
          '  static const $inputClassName $propertyName = $inputClassName._();',
        );
        buffer.writeln('');
      }
    }

    // Write number inputs
    if (numbers.isNotEmpty) {
      buffer.writeln('  // Number inputs');
      for (final number in numbers) {
        final inputClassName = NamingUtils.generateClassName(
          '${stateMachine.name}_${number.name}_number',
        );
        final propertyName = NamingUtils.generatePropertyName(number.name);

        buffer.writeln('  /// ${number.name} number input');
        buffer.writeln(
          '  static const $inputClassName $propertyName = $inputClassName._();',
        );
        buffer.writeln('');
      }
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write input classes
  void _writeInputClasses(StringBuffer buffer) {
    for (final artboard in asset.artboards) {
      for (final stateMachine in artboard.stateMachines) {
        for (final input in stateMachine.inputs) {
          _writeInputClass(buffer, stateMachine, input);
        }
      }
    }
  }

  /// Write individual input class
  void _writeInputClass(
    StringBuffer buffer,
    RiveStateMachine stateMachine,
    RiveInput input,
  ) {
    final typeStr = input.type.name;
    final inputClassName = NamingUtils.generateClassName(
      '${stateMachine.name}_${input.name}_$typeStr',
    );

    buffer.writeln('/// ${input.name} ${input.type.name} input');
    buffer.writeln('class $inputClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $inputClassName._();');
    buffer.writeln('');

    // Basic properties
    buffer.writeln('  /// Input name');
    buffer.writeln("  static const String name = '${input.name}';");
    buffer.writeln('');
    buffer.writeln('  /// Input type');
    buffer.writeln(
      '  static const RiveInputType type = RiveInputType.${input.type.name};',
    );
    buffer.writeln('');

    // Type-specific properties
    switch (input.type) {
      case RiveInputType.boolean:
        if (input is RiveBooleanInput) {
          buffer.writeln('  /// Initial value');
          buffer.writeln(
            '  static const bool initialValue = ${input.initialValue};',
          );
          buffer.writeln('');
        }
        break;
      case RiveInputType.number:
        if (input is RiveNumberInput) {
          buffer.writeln('  /// Initial value');
          buffer.writeln(
            '  static const double initialValue = ${input.initialValue};',
          );
          buffer.writeln('');
          if (input.minValue != null) {
            buffer.writeln('  /// Minimum value');
            buffer.writeln(
              '  static const double? minValue = ${input.minValue};',
            );
            buffer.writeln('');
          }
          if (input.maxValue != null) {
            buffer.writeln('  /// Maximum value');
            buffer.writeln(
              '  static const double? maxValue = ${input.maxValue};',
            );
            buffer.writeln('');
          }
        }
        break;
      case RiveInputType.trigger:
        // Triggers don't have additional properties
        break;
    }

    buffer.writeln('}');
    buffer.writeln('');
  }
}
