/// Generator for constants and utilities.
///
/// This file is a placeholder and will be expanded in the future.
library;

import '../config/rive_gen_config.dart';
import '../models/models.dart';
import '../utils/utils.dart';

/// Generator for constants classes with comprehensive Rive metadata.
class ConstantsGenerator {
  /// The list of Rive assets to generate constants for
  final List<RiveAsset> assets;

  /// The generator configuration
  final RiveGenConfig config;

  /// Constructor
  const ConstantsGenerator({required this.assets, required this.config});

  /// Generate the complete constants class code
  String generate() {
    final buffer = StringBuffer();

    // File header and imports
    _writeHeader(buffer);

    // Main constants class
    _writeConstantsClass(buffer);

    // Asset path constants
    _writeAssetPathConstants(buffer);

    // Animation constants
    _writeAnimationConstants(buffer);

    // State machine constants
    _writeStateMachineConstants(buffer);

    // Input constants
    _writeInputConstants(buffer);

    return buffer.toString();
  }

  /// Write file header and documentation
  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by rive_gen');
    buffer.writeln('');
    buffer.writeln('/// Constants for all Rive assets');
    buffer.writeln('/// ');
    buffer.writeln('/// This file contains type-safe constant definitions for');
    buffer.writeln('/// asset paths, animation names, state machine names,');
    buffer.writeln('/// input names, and other metadata.');
    buffer.writeln('library rive_constants;');
    buffer.writeln('');
  }

  /// Write the main constants class
  void _writeConstantsClass(StringBuffer buffer) {
    buffer.writeln('/// Main constants class for all Rive assets');
    buffer.writeln('abstract class RiveConstants {');
    buffer.writeln('  /// Private constructor to prevent instantiation');
    buffer.writeln('  const RiveConstants._();');
    buffer.writeln('');

    // Asset count
    buffer.writeln('  /// Total number of Rive assets');
    buffer.writeln('  static const int assetCount = ${assets.length};');
    buffer.writeln('');

    // Total counts across all assets
    final totalAnimations = assets.fold<int>(
      0,
      (sum, asset) =>
          sum +
          asset.artboards.fold<int>(
            0,
            (artboardSum, artboard) => artboardSum + artboard.animations.length,
          ),
    );

    final totalStateMachines = assets.fold<int>(
      0,
      (sum, asset) =>
          sum +
          asset.artboards.fold<int>(
            0,
            (artboardSum, artboard) =>
                artboardSum + artboard.stateMachines.length,
          ),
    );

    final totalInputs = assets.fold<int>(
      0,
      (sum, asset) =>
          sum +
          asset.artboards.fold<int>(
            0,
            (artboardSum, artboard) =>
                artboardSum +
                artboard.stateMachines.fold<int>(
                  0,
                  (smSum, sm) => smSum + sm.inputs.length,
                ),
          ),
    );

    buffer.writeln('  /// Total number of animations across all assets');
    buffer.writeln('  static const int totalAnimations = $totalAnimations;');
    buffer.writeln('');
    buffer.writeln('  /// Total number of state machines across all assets');
    buffer.writeln(
      '  static const int totalStateMachines = $totalStateMachines;',
    );
    buffer.writeln('');
    buffer.writeln('  /// Total number of inputs across all assets');
    buffer.writeln('  static const int totalInputs = $totalInputs;');
    buffer.writeln('');

    // Asset paths list
    buffer.writeln('  /// All asset paths');
    buffer.writeln('  static const List<String> assetPaths = [');
    for (final asset in assets) {
      buffer.writeln("    '${asset.path}',");
    }
    buffer.writeln('  ];');
    buffer.writeln('');

    // Asset names list
    buffer.writeln('  /// All asset names');
    buffer.writeln('  static const List<String> assetNames = [');
    for (final asset in assets) {
      buffer.writeln("    '${asset.name}',");
    }
    buffer.writeln('  ];');
    buffer.writeln('');

    // Nested constant classes
    buffer.writeln('  /// Asset path constants');
    buffer.writeln('  static const AssetPaths paths = AssetPaths._();');
    buffer.writeln('');
    buffer.writeln('  /// Animation name constants');
    buffer.writeln(
      '  static const AnimationNames animations = AnimationNames._();',
    );
    buffer.writeln('');
    buffer.writeln('  /// State machine name constants');
    buffer.writeln(
      '  static const StateMachineNames stateMachines = StateMachineNames._();',
    );
    buffer.writeln('');
    buffer.writeln('  /// Input name constants');
    buffer.writeln('  static const InputNames inputs = InputNames._();');
    buffer.writeln('');

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write asset path constants
  void _writeAssetPathConstants(StringBuffer buffer) {
    buffer.writeln('/// Asset path constants');
    buffer.writeln('abstract class AssetPaths {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const AssetPaths._();');
    buffer.writeln('');

    for (final asset in assets) {
      final constantName = NamingUtils.toSnakeCase(asset.name).toUpperCase();
      buffer.writeln('  /// Path to ${asset.name}.riv');
      buffer.writeln("  static const String $constantName = '${asset.path}';");
      buffer.writeln('');
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write animation constants
  void _writeAnimationConstants(StringBuffer buffer) {
    buffer.writeln('/// Animation name constants');
    buffer.writeln('abstract class AnimationNames {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const AnimationNames._();');
    buffer.writeln('');

    // Collect all unique animation names
    final animationNames = <String>{};
    for (final asset in assets) {
      for (final artboard in asset.artboards) {
        for (final animation in artboard.animations) {
          animationNames.add(animation.name);
        }
      }
    }

    // Write constants for unique animation names
    for (final animationName in animationNames.toList()..sort()) {
      final constantName = NamingUtils.toSnakeCase(animationName).toUpperCase();
      buffer.writeln('  /// Animation: $animationName');
      buffer.writeln("  static const String $constantName = '$animationName';");
      buffer.writeln('');
    }

    // Asset-specific animation classes
    for (final asset in assets) {
      final hasAnimations = asset.artboards.any(
        (artboard) => artboard.animations.isNotEmpty,
      );
      if (hasAnimations) {
        final assetClassName = NamingUtils.generateClassName(
          '${asset.name}_animations',
        );
        buffer.writeln('  /// Animations for ${asset.name}');
        buffer.writeln(
          '  static const $assetClassName ${NamingUtils.generatePropertyName(asset.name)} = $assetClassName._();',
        );
        buffer.writeln('');
      }
    }

    buffer.writeln('}');
    buffer.writeln('');

    // Individual asset animation classes
    for (final asset in assets) {
      final hasAnimations = asset.artboards.any(
        (artboard) => artboard.animations.isNotEmpty,
      );
      if (hasAnimations) {
        _writeAssetAnimationConstants(buffer, asset);
      }
    }
  }

  /// Write animation constants for a specific asset
  void _writeAssetAnimationConstants(StringBuffer buffer, RiveAsset asset) {
    final assetClassName = NamingUtils.generateClassName(
      '${asset.name}_animations',
    );

    buffer.writeln('/// Animation constants for ${asset.name}.riv');
    buffer.writeln('abstract class $assetClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $assetClassName._();');
    buffer.writeln('');

    // Group animations by artboard
    for (final artboard in asset.artboards) {
      if (artboard.animations.isEmpty) continue;

      buffer.writeln('  // ${artboard.name} artboard animations');
      for (final animation in artboard.animations) {
        final constantName = NamingUtils.toSnakeCase(
          '${artboard.name}_${animation.name}',
        ).toUpperCase();
        buffer.writeln(
          '  /// ${animation.name} animation from ${artboard.name} artboard',
        );
        buffer.writeln(
          "  static const String $constantName = '${animation.name}';",
        );
        buffer.writeln('');
      }
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write state machine constants
  void _writeStateMachineConstants(StringBuffer buffer) {
    buffer.writeln('/// State machine name constants');
    buffer.writeln('abstract class StateMachineNames {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const StateMachineNames._();');
    buffer.writeln('');

    // Collect all unique state machine names
    final stateMachineNames = <String>{};
    for (final asset in assets) {
      for (final artboard in asset.artboards) {
        for (final stateMachine in artboard.stateMachines) {
          stateMachineNames.add(stateMachine.name);
        }
      }
    }

    // Write constants for unique state machine names
    for (final smName in stateMachineNames.toList()..sort()) {
      final constantName = NamingUtils.toSnakeCase(smName).toUpperCase();
      buffer.writeln('  /// State machine: $smName');
      buffer.writeln("  static const String $constantName = '$smName';");
      buffer.writeln('');
    }

    // Asset-specific state machine classes
    for (final asset in assets) {
      final hasStateMachines = asset.artboards.any(
        (artboard) => artboard.stateMachines.isNotEmpty,
      );
      if (hasStateMachines) {
        final assetClassName = NamingUtils.generateClassName(
          '${asset.name}_state_machines',
        );
        buffer.writeln('  /// State machines for ${asset.name}');
        buffer.writeln(
          '  static const $assetClassName ${NamingUtils.generatePropertyName(asset.name)} = $assetClassName._();',
        );
        buffer.writeln('');
      }
    }

    buffer.writeln('}');
    buffer.writeln('');

    // Individual asset state machine classes
    for (final asset in assets) {
      final hasStateMachines = asset.artboards.any(
        (artboard) => artboard.stateMachines.isNotEmpty,
      );
      if (hasStateMachines) {
        _writeAssetStateMachineConstants(buffer, asset);
      }
    }
  }

  /// Write state machine constants for a specific asset
  void _writeAssetStateMachineConstants(StringBuffer buffer, RiveAsset asset) {
    final assetClassName = NamingUtils.generateClassName(
      '${asset.name}_state_machines',
    );

    buffer.writeln('/// State machine constants for ${asset.name}.riv');
    buffer.writeln('abstract class $assetClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $assetClassName._();');
    buffer.writeln('');

    // Group state machines by artboard
    for (final artboard in asset.artboards) {
      if (artboard.stateMachines.isEmpty) continue;

      buffer.writeln('  // ${artboard.name} artboard state machines');
      for (final stateMachine in artboard.stateMachines) {
        final constantName = NamingUtils.toSnakeCase(
          '${artboard.name}_${stateMachine.name}',
        ).toUpperCase();
        buffer.writeln(
          '  /// ${stateMachine.name} state machine from ${artboard.name} artboard',
        );
        buffer.writeln(
          "  static const String $constantName = '${stateMachine.name}';",
        );
        buffer.writeln('');

        // State constants for this state machine
        if (stateMachine.states.isNotEmpty) {
          buffer.writeln('  // States for ${stateMachine.name}');
          for (final state in stateMachine.states) {
            final stateConstantName = NamingUtils.toSnakeCase(
              '${artboard.name}_${stateMachine.name}_$state',
            ).toUpperCase();
            buffer.writeln('  /// $state state');
            buffer.writeln(
              "  static const String $stateConstantName = '$state';",
            );
            buffer.writeln('');
          }
        }
      }
    }

    buffer.writeln('}');
    buffer.writeln('');
  }

  /// Write input constants
  void _writeInputConstants(StringBuffer buffer) {
    buffer.writeln('/// Input name constants');
    buffer.writeln('abstract class InputNames {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const InputNames._();');
    buffer.writeln('');

    // Collect all unique input names by type
    final triggerInputs = <String>{};
    final booleanInputs = <String>{};
    final numberInputs = <String>{};

    for (final asset in assets) {
      for (final artboard in asset.artboards) {
        for (final stateMachine in artboard.stateMachines) {
          for (final input in stateMachine.inputs) {
            switch (input.type) {
              case RiveInputType.trigger:
                triggerInputs.add(input.name);
                break;
              case RiveInputType.boolean:
                booleanInputs.add(input.name);
                break;
              case RiveInputType.number:
                numberInputs.add(input.name);
                break;
            }
          }
        }
      }
    }

    // Write trigger inputs
    if (triggerInputs.isNotEmpty) {
      buffer.writeln('  // Trigger inputs');
      for (final inputName in triggerInputs.toList()..sort()) {
        final constantName = NamingUtils.toSnakeCase(
          'trigger_$inputName',
        ).toUpperCase();
        buffer.writeln('  /// Trigger input: $inputName');
        buffer.writeln("  static const String $constantName = '$inputName';");
        buffer.writeln('');
      }
    }

    // Write boolean inputs
    if (booleanInputs.isNotEmpty) {
      buffer.writeln('  // Boolean inputs');
      for (final inputName in booleanInputs.toList()..sort()) {
        final constantName = NamingUtils.toSnakeCase(
          'boolean_$inputName',
        ).toUpperCase();
        buffer.writeln('  /// Boolean input: $inputName');
        buffer.writeln("  static const String $constantName = '$inputName';");
        buffer.writeln('');
      }
    }

    // Write number inputs
    if (numberInputs.isNotEmpty) {
      buffer.writeln('  // Number inputs');
      for (final inputName in numberInputs.toList()..sort()) {
        final constantName = NamingUtils.toSnakeCase(
          'number_$inputName',
        ).toUpperCase();
        buffer.writeln('  /// Number input: $inputName');
        buffer.writeln("  static const String $constantName = '$inputName';");
        buffer.writeln('');
      }
    }

    // Asset-specific input classes
    for (final asset in assets) {
      final hasInputs = asset.artboards.any(
        (artboard) => artboard.stateMachines.any((sm) => sm.inputs.isNotEmpty),
      );
      if (hasInputs) {
        final assetClassName = NamingUtils.generateClassName(
          '${asset.name}_inputs',
        );
        buffer.writeln('  /// Inputs for ${asset.name}');
        buffer.writeln(
          '  static const $assetClassName ${NamingUtils.generatePropertyName(asset.name)} = $assetClassName._();',
        );
        buffer.writeln('');
      }
    }

    buffer.writeln('}');
    buffer.writeln('');

    // Individual asset input classes
    for (final asset in assets) {
      final hasInputs = asset.artboards.any(
        (artboard) => artboard.stateMachines.any((sm) => sm.inputs.isNotEmpty),
      );
      if (hasInputs) {
        _writeAssetInputConstants(buffer, asset);
      }
    }
  }

  /// Write input constants for a specific asset
  void _writeAssetInputConstants(StringBuffer buffer, RiveAsset asset) {
    final assetClassName = NamingUtils.generateClassName(
      '${asset.name}_inputs',
    );

    buffer.writeln('/// Input constants for ${asset.name}.riv');
    buffer.writeln('abstract class $assetClassName {');
    buffer.writeln('  /// Private constructor');
    buffer.writeln('  const $assetClassName._();');
    buffer.writeln('');

    // Group inputs by artboard and state machine
    for (final artboard in asset.artboards) {
      for (final stateMachine in artboard.stateMachines) {
        if (stateMachine.inputs.isEmpty) continue;

        buffer.writeln('  // ${stateMachine.name} state machine inputs');
        for (final input in stateMachine.inputs) {
          final constantName = NamingUtils.toSnakeCase(
            '${artboard.name}_${stateMachine.name}_${input.name}',
          ).toUpperCase();
          buffer.writeln(
            '  /// ${input.name} ${input.type.name} input from ${stateMachine.name}',
          );
          buffer.writeln(
            "  static const String $constantName = '${input.name}';",
          );
          buffer.writeln('');
        }
      }
    }

    buffer.writeln('}');
    buffer.writeln('');
  }
}
